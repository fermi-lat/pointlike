"""
Convolution interface for like2
Extends classes from uw.utilities 


$Header: /nfs/slac/g/glast/ground/cvs/pointlike/python/uw/like2/convolution.py,v 1.4 2013/11/10 04:27:27 burnett Exp $
author:  Toby Burnett
"""
import os, pickle, zipfile 
import numpy as np
import pandas as pd
from uw.utilities import keyword_options
from uw.utilities import convolution as utilities_convolution

import skymaps #from Science Tools: for SkyDir 

class FillMixin(object):
    """A Mixin class for like2 convolution, to replace functions in utilities.convolution
    """
    def fill(self, skyfun):
        """ Evaluate skyfun along the internal grid and return the resulting array.
        (Identical to superclass, except skyfun can be either a python functor or a 
        C++ SkySkySpectrum)
        """
        v = np.empty(self.npix*self.npix)
        if isinstance(skyfun, skymaps.SkySpectrum):
            skymaps.PythonUtilities.val_grid(v,self.lons,self.lats,self.center,skyfun)
        else:
            def pyskyfun(u):
                return skyfun(skymaps.SkyDir(skymaps.Hep3Vector(u[0],u[1],u[2])))
            skymaps.PythonUtilities.val_grid(v,self.lons,self.lats,self.center,
                skymaps.PySkyFunction(pyskyfun))
        return v.reshape([self.npix,self.npix])
        
    def bg_fill(self, exp, dm, cache=None, ignore_nan=False):
        """ Evaluate product of exposure and diffuse map on the grid
        exp : SkyFunction for exposure
        dm  : [SkyFuntion for diffuse map | None]
            If None, expect predetermined values in cache, which may be an array or a scalar
        """
        #print 'filling with product of exposure "%s" model "%s"' % (exp, dm)
        
        if dm is None:
            assert cache is not None, 'Logic error'
            self.bg_vals = self.fill(exp) * cache
        else:
            def exp_dm(skydir):
                    return exp(skydir)*dm(skydir)
            self.bg_vals = self.fill(exp_dm)
    
        #self.bg_vals = self.fill(exp) * (self.fill(dm) if cache is None else cache) #product of exposure and map
        #self.dm_vals = self.fill(dm) #temporary
        #self.exp_vals = self.fill(exp)
        # check for nans, replace with zeros if not full ROI
        nans = np.isnan(self.bg_vals)
        if np.all(nans):
            raise Exception('Diffuse source %s has no overlap with ROi' % dm.filename)
        if np.any(nans) and ignore_nan:
            self.bg_vals[nans]=0
            
    def psf_fill(self, psf):
        """ Evaluate PSF on the grid
        """
        #print 'filling with psf %s' % psf
        psf_vals = psf(self.dists).reshape([self.npix,self.npix])
        self.psf_vals = psf_vals / psf_vals.sum()
        
    def set_npix(self, psf, edge=0, r_multi=1.2, r_max=20):
        """ modify the npix with
            psf : PSF object
            edge: float --Source size (degrees)
            r_multi   float multiple of r95 to set max dimension of grid
            r_max     float an absolute maximum (half)-size of grid (deg)
            """
        r95 = psf.inverse_integral(95)
        rad = r_multi*r95 + edge
        rad = max(min(r_max,rad),edge+2.5)
        npix = int(round(2*rad/self.pixelsize))
        npix += (npix%2 == 0)
        return npix


class ShowMixin(object):
    """ A mixin class to add or replace show methods
    """
    def show_vals(self, vals=None, ax=None, roi_radius=5, roi_dir=None, colorbar=True, npix=None, **kw):
        """Make a display.
        vals : 2-d array of float
            generated by the fill method; expect to be npix x npix
        npix : [int | None]
            if int, override self.npix to for central npix x npix
        """
        import pylab as plt
        if ax is None: fig,ax=plt.subplots()
        if vals is None: vals = self.cvals
        if npix is not None and npix!=self.npix:
            delta = (self.npix-npix)/2
            assert delta>0, 'npix not >= self.npix'
            tvals = vals[delta:delta+npix, delta:delta+npix]
        else: 
            npix=self.npix; tvals = vals
        if roi_radius is not None:
            if roi_dir is None: roi_dir = self.center
            circle = plt.Circle(self.pix(roi_dir),roi_radius/self.pixelsize, color='grey', lw=2,fill=False)
            ax.add_artist(circle)

        v = ax.imshow( tvals.transpose()[::-1],  interpolation='nearest', **kw)
        marker = float(npix)/2
        ax.axvline(marker,color='k')
        ax.axhline(marker,color='k')
        if colorbar: 
            cb = plt.colorbar(v, shrink=0.8)
        def scale(x, factor=1.0):
            return x*factor/self.pixelsize+self.npix/2.
        r = np.arange(-8,9,4)
        ax.set_xticks(scale(r))
        ax.set_xticklabels(map(lambda x:'%.0f'%x ,r))
        ax.set_yticks(scale(r, -1))
        ax.set_yticklabels(map(lambda x:'%.0f'%x ,r))
        return ax.figure
            
    def show(self, roi_radius=None,roi_dir=None, **kwargs):
        """Three subplots: PSF, raw, convolved"""
        import pylab as plt
        from matplotlib.colors import LogNorm
        title = kwargs.pop('title', None)
        if hasattr(self, 'band'):
            roi_radius = self.band.radius
            roi_dir = self.band.sd
        fig, axx = plt.subplots(1,3, figsize=(10,3), sharex=True, sharey=True)
        plt.subplots_adjust(wspace=0.05)
        if hasattr(self, 'psf_vals'):
            axx[0].imshow(self.psf_vals,interpolation='nearest')
        vmax = self.bg_vals.max()
        norm = LogNorm(vmax=vmax, vmin=vmax/1e3)
        marker = float(self.npix)/2
        for ax,what in zip(axx[1:], (self.bg_vals, self.cvals)  ):
            what[what==0]=vmax/1e6
            ax.imshow(what.transpose()[::-1], norm=norm, interpolation='nearest')
            ax.axvline(marker,color='grey')
            ax.axhline(marker,color='grey')
            if roi_radius is not None:
                if roi_dir is None: roi_dir = self.center
                circle = plt.Circle(self.pix(roi_dir),roi_radius/self.pixelsize, color='grey', lw=2,fill=False)
                ax.add_artist(circle)
        axx[0].set_aspect(1.0)
        if title is not None:
            plt.suptitle(title,fontsize='small')
            
        return fig

class ConvolvableGrid(FillMixin, ShowMixin, utilities_convolution.BackgroundConvolution):
    """ Convolution used by response classes. This subclass uses the mixin classes defined here to:
    
      1) changes the default for a bounds error (to check)
      2) Replaces fill method with version that works for python class
      3) provides useful show methods
      """
    defaults =(
        ('pixelsize', 0.1, 'Size of pixels to use for convolution grid'),
        ('npix',      201, 'Number of pixels (must be an odd number'),
        )

    @keyword_options.decorate(defaults)
    def __init__(self, center, **kwargs):
        """ center -- a SkyDir giving the center of the grid on which to convolve bg
            kwargs are passed to Grid.
        """
        keyword_options.process(self, kwargs)
        defaults=dict(bounds_error=False)
        defaults.update(kwargs)
        # note do not use code in superclass needing psf, diffuse function
        super(ConvolvableGrid, self).__init__(center, None, None, **defaults)
        self.center = center
        
    def __repr__(self):
        return '%s.%s: center %s npix %d pixelsize %.2f' %(
            self.__module__,self.__class__.__name__, self.center, self.npix, self.pixelsize)

