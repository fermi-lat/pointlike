"""
Convolution interface for like2
Extends classes from uw.utilities 


$Header: /nfs/slac/g/glast/ground/cvs/pointlike/python/uw/like2/convolution.py,v 1.1 2013/10/29 03:23:52 burnett Exp $
author:  Toby Burnett
"""
import os, pickle, zipfile 
import numpy as np
import pandas as pd
from uw.utilities import keyword_options
from uw.utilities import convolution as utilities_convolution

import skymaps #from Science Tools: for SkyDir 

class FillMixin(object):
    """A Mixin class for like2 convolution, to replace functions in utilities.convolution
    """
    def fill(self, skyfun):
        """ Evaluate skyfun along the internal grid and return the resulting array.
        (Identical to superclass, except skyfun can be either a python functor or a 
        C++ SkySkySpectrum)
        """
        v = np.empty(self.npix*self.npix)
        if isinstance(skyfun, skymaps.SkySpectrum):
            skymaps.PythonUtilities.val_grid(v,self.lons,self.lats,self.center,skyfun)
        else:
            def pyskyfun(u):
                return skyfun(skymaps.SkyDir(skymaps.Hep3Vector(u[0],u[1],u[2])))
            skymaps.PythonUtilities.val_grid(v,self.lons,self.lats,self.center,
                skymaps.PySkyFunction(pyskyfun))
        return v.reshape([self.npix,self.npix])
        
    def bg_fill(self, exp, dm, cache=None, ignore_nan=False):
        """ Evaluate product of exposure and diffuse map on the grid
        exp : SkyFunction for exposure
        dm  : [SkyFuntion for diffuse map | None]
            If None, expect predetermined values in cache
        """
        #print 'filling with product of exposure "%s" model "%s"' % (exp, dm)
        self.bg_vals = self.fill(exp) * (self.fill(dm) if cache is None else cache) #product of exposure and map
        #self.dm_vals = self.fill(dm) #temporary
        #self.exp_vals = self.fill(exp)
        # check for nans, replace with zeros if not full ROI
        nans = np.isnan(self.bg_vals)
        if np.all(nans):
            raise eException('Diffuse source %s has no overlap with ROi' % dm.filename)
        if np.any(nans) and ignore_nan:
            self.bg_vals[nans]=0
            
    def psf_fill(self, psf):
        """ Evaluate PSF on the grid
        """
        #print 'filling with psf %s' % psf
        psf_vals = psf(self.dists).reshape([self.npix,self.npix])
        self.psf_vals = psf_vals / psf_vals.sum()
        
    def set_npix(self, psf, edge=0, r_multi=1.2, r_max=20):
        """ modify the npix with
            psf : PSF object
            edge: float --Source size (degrees)
            r_multi   float multiple of r95 to set max dimension of grid
            r_max     float an absolute maximum (half)-size of grid (deg)
            """
        r95 = psf.inverse_integral(95)
        rad = r_multi*r95 + edge
        rad = max(min(r_max,rad),edge+2.5)
        npix = int(round(2*rad/self.pixelsize))
        npix += (npix%2 == 0)
        return npix
        #self.setup_grid(npix, self.pixelsize)


class ShowMixin(object):
    """ A mixin class to add or replace show methods
    """
    def show_vals(self, vals=None, ax=None, colorbar=True, npix=None, **kw):
        """Make a display.
        vals : 2-d array of float
            generated by the fill method; expect to be npix x npix
        npix : [int | None]
            if int, override self.npix to for central npix x npix
        """
        import pylab as plt
        if ax is None: fig,ax=plt.subplots()
        if vals is None: vals = self.cvals
        if npix is not None and npix!=self.npix:
            delta = (self.npix-npix)/2
            assert delta>0, 'npix not >= self.npix'
            tvals = vals[delta:delta+npix, delta:delta+npix]
        else: 
            npix=self.npix; tvals = vals
        v = ax.imshow( tvals.transpose()[::-1],  interpolation='nearest', **kw)
        marker = float(npix)/2
        ax.axvline(marker,color='k')
        ax.axhline(marker,color='k')
        if colorbar: plt.colorbar(v)
        def scale(x, factor=1.0):
            return x*factor/self.pixelsize+self.npix/2.
        r = np.arange(-8,9,4)
        ax.set_xticks(scale(r))
        ax.set_xticklabels(map(lambda x:'%.0f'%x ,r))
        ax.set_yticks(scale(r, -1))
        ax.set_yticklabels(map(lambda x:'%.0f'%x ,r))
        return ax.figure
            
    def show(self, roi_radius=None,roi_dir=None, **kwargs):
        """Three subplots: PSF, raw, convolved"""
        import pylab as plt
        from matplotlib.colors import LogNorm
        title = kwargs.pop('title', None)
        if hasattr(self, 'band'):
            roi_radius = self.band.radius
            roi_dir = self.band.sd
        fig, axx = plt.subplots(1,3, figsize=(10,3), sharex=True, sharey=True)
        plt.subplots_adjust(wspace=0.05)
        if hasattr(self, 'psf_vals'):
            axx[0].imshow(self.psf_vals,interpolation='nearest')
        vmax = self.bg_vals.max()
        norm = LogNorm(vmax=vmax, vmin=vmax/1e3)
        marker = float(self.npix)/2
        for ax,what in zip(axx[1:], (self.bg_vals, self.cvals)  ):
            what[what==0]=vmax/1e6
            ax.imshow(what.transpose()[::-1], norm=norm, interpolation='nearest')
            ax.axvline(marker,color='grey')
            ax.axhline(marker,color='grey')
            if roi_radius is not None:
                if roi_dir is None: roi_dir = self.center
                circle = plt.Circle(self.pix(roi_dir),roi_radius/self.pixelsize, color='grey', lw=2,fill=False)
                ax.add_artist(circle)
        axx[0].set_aspect(1.0)
        if title is not None:
            plt.suptitle(title,fontsize='small')
            
        return fig

class ConvolvableGrid(FillMixin, ShowMixin, utilities_convolution.BackgroundConvolution):
    """ Convolution used by classes below. This subclass uses the mixin classes defined here to:
    
      1) changes the default for a bounds error (to check)
      2) Replaces fill method with version that works for python class
      3) provides useful show methods
      """
    def __init__(self,band, **kwargs):
        """ center -- a SkyDir giving the center of the grid on which to convolve bg
            kwargs are passed to Grid.
        """
        defaults=dict(bounds_error=False)
        defaults.update(kwargs)
        # note do not use code in superclass needing psf, diffuse function
        super(ConvolvableGrid, self).__init__(band.sd, None, None, **defaults)
        self.band=band
        
    def __repr__(self):
        return '%s.%s: center %s npix %d' %(self.__module__,self.__class__.__name__, self.center, self.npix)
    def overlap(self): return 1.0
    def exposure_ratio(self): return 1.0

class GridGenerator(object):
    """Base class for creation of local grid for global diffuse models
    Note that it applies to a particular subtype (front, back ....)
    """
    defaults =(
        ('pixelsize',0.25,'Pixel size for convolution grid'),
        ('npix', 61, 'number of pixels for 5 deg'),
        ('ignore_nan', True, 'replace nan values with zero (generates warning)'), 
        )

    @keyword_options.decorate(defaults)
    def __init__(self, band, diffuse_source, **kwargs): #psf, exposure, roi_dir, diffuse_source,  **kwargs):
        """
        Factory class to create grids of convolved diffuse
        
        parameters
        ----------
        band : ROIBand or equivalent
            Contains position, psf, exposure, selected for a particular event type

        diffuse_source : DiffuseBase object. It must be for the same event type, if relevant
        """
        keyword_options.process(self, kwargs)
        self.roi_dir = band.sd #roi_dir
        self.psf, self.exposure = band.psf, band.exposure
        self.band=band
        self.diffuse_source = diffuse_source
        self.name = diffuse_source.name
        
    def __repr__(self):
        return '%s for %s' % (self.__class__.__name__, self.diffuse_source.__repr__() )
        
    def set_npix(self,  edge=0, r_multi=1.2, r_max=20):
        """ modify the npix with
            edge: float --Source size (degrees)
            r_multi   float multiple of r95 to set max dimension of grid
            r_max     float an absolute maximum (half)-size of grid (deg)
            """
        r95 = self.psf.inverse_integral(95)
        rad = r_multi*r95 + edge + self.band.radius
        rad = max(min(r_max,rad),edge+2.5)
        npix = int(round(2*rad/self.pixelsize))
        npix += (npix%2 == 0)
        return npix
   
    def _get_convolver(self):
        """ load a convolution object with npix adjusted for current energy""" 
        npix = self.set_npix()
        return ConvolvableGrid(self.band, npix=npix, pixelsize=self.pixelsize)
        
    def __call__(self, energy, tol=0.5):
        """ return a convolved grid for a band in an ROI
        parameters
        ----------
        energy : float
            intermediate energy for the band
        """
        # First set energy in appropriated places (perhaps Band should know how to do this)
        dm = self.diffuse_source
        if hasattr(dm, 'setEnergy'): # case for extended
            dm.setEnergy(energy)
        self.exposure.setEnergy(energy)
        self.psf.setEnergy(energy)
        
        # get the convolution class, with perhaps new npix
        grid = self._get_convolver()
        
        grid.bg_fill(self.exposure,dm)
         
        #set the PSF map
        grid.psf_fill(self.psf)

        # finally convolve it unless fairly flat or psf is very local
        bgmax, bgmin = grid.bg_vals.max(), grid.bg_vals.min()
        if bgmax==0 or (bgmax-bgmin)/bgmax < tol:
            grid.cvals = grid.bg_vals
        else:
            grid.convolve()
        return grid


class ExtendedConvolvableGrid(ConvolvableGrid):
    """ like2 convolver for extended sources
    Uses uw.utilities.convolution.BackgroundConvolution for convolving
    """
    def __init__(self, band,  center, pixelsize=0.1, npix=201):
        """ center : 
        
        """

        super(ExtendedConvolvableGrid, self).__init__(band, pixelsize=pixelsize, npix=npix)
        #self.band=band
        
    def __repr__(self):
        return '%s.%s: center %s npix %d' %(self.__module__,self.__class__.__name__, self.center, self.npix)

    def overlap(self):
        """ Calculate the fraction of PDF contained within ROI (which
            is defined by the input radius and center). This is the extended
            source analog of the pypsf.PsfOverlap object. It is convenient
            to return just the overlap fraction since it is known that
            the entire spatial part is normalized.

            Note that this formula assumes the entire extended source is
            within the grid, which should be enforced by a reasonable
            choice of r_max and r_multi."""
        
        roi_center = self.band.sd
        roi_radius = self.band.radius
        x,y = self.pix(roi_center)
        dx =np.arange(0,self.npix)-x
        dy =np.arange(0,self.npix)-y
        d2  = dx**2+dy**2
        inside = d2 < (roi_radius/self.pixelsize)**2
        return self.cvals[inside].sum() / self.cvals.sum() 
        
    def exposure_ratio(self):
        return self.band.exposure(self.center)/self.band.exposure(self.band.sd)
 
class ExtendedGridGenerator(GridGenerator):
    def __init__(self, band, extended_source, pixelsize=0.1):
        super(ExtendedGridGenerator, self).__init__(band,  extended_source)
        self.extended_source=extended_source
        self.pixelsize=pixelsize
        self.band=band

    def _get_convolver(self):
        return ExtendedConvolvableGrid(self.band, self.extended_source.center, pixelsize=self.pixelsize)  

class CachedGridGenerator(GridGenerator):
    def __init__(self, band, center, dfun, **kwargs):
        self.center=center
        self.band = band
        self.psf=band.psf
        self.exposure=band.exposure
        self.__dict__.update(kwargs)
        self.quiet = True# kwargs['quiet']
        self.npix=61
        self.diffuse_source = dfun
        roi_index = skymaps.Band(12).index(center)
        try:
            self.filename = dfun.files[roi_index]
            self.cached_diffuse = pickle.load(dfun.opener(self.filename))
        except Exception, msg:
            raise Exception( 'Diffuse cache file # %d not found:%s' %(roi_index,msg))
        self.emins = [cd['emin'] for cd in self.cached_diffuse]
        if hasattr(dfun, 'kw') and dfun.kw is not None: # check for extra keywords from diffuse spec.
            # Manage keywords found in the 
            if dfun.kw['correction'] is not None:
                if not self.quiet:print '\t%s loading corrections from %s.kw:' % (self.__class__.__name__, dfun.__class__.__name__)
                df = pd.read_csv(dfun.kw['correction'], index_col=0) 
                self.corr = df.ix['HP12_%04d'%roi_index].values
                if not self.quiet:print '\tcorrection file: "%s"' % dfun.kw['correction']
                if not self.quiet:print '\tcorrections: %s' %self.corr.round(3)
            else: self.corr=None
            self.systematic = dfun.kw.get('systematic', None)
            if self.systematic is not None:
                if not self.quiet:print '\tsystematic: %.3f' % self.systematic


    def __call__(self, energy):
        grid = ConvolvableGrid(self.band)
        grid.cvals = np.zeros((self.npix, self.npix))
        grid.energy=energy
        # find the appropriate cached grid
        for index in range(len(self.emins)):
            if energy>self.emins[index] and (index==len(self.emins)-1 or energy<self.emins[index+1])\
                : break
        emin = self.emins[index]    
        assert energy/emin < 1.8 and energy> emin, 'too large a factor: energy, emin=%.0f,%.0f\nemins=%s' % (energy, emin, self.emins)
        cd = self.cached_diffuse[index]
        
        # create a convolvable grid from it, with current PSF
        energy = cd['energy']
        if cd['center']!=self.band.sd:
            print 'WARNING: Logic error? %s not %s' % (cd['center'], self.band.sd)
        grid = ConvolvableGrid(self.band,   npix=cd['npix'], pixelsize=cd['pixelsize'])
            
        # determine the current exposure for this energy 
        exp = self.exposure
        exp.setEnergy(energy)
        self.psf.setEnergy(energy)
        grid.psf_fill(self.psf)
        
        # apply correction factor if any; use last value for all higher (depends only on energy)
        vals = cd['vals']
        ds = self.diffuse_source
        if hasattr(ds, 'corr') and ds.corr is not None:
            c = ds.corr[index] if index<len(ds.corr) else ds.corr[-1]
            vals *= c

        # finally do the convolution on the product of exposure and diffuse map, which is passed in 
        grid.bg_fill(exp, None, cache=vals)
        grid.convolve()
        return grid
        