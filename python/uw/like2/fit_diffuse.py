"""
Fit diffuse 
"""
import os, glob, pickle
import numpy as np
import pylab as plt
import pandas as pd
from skymaps import SkyDir, Band 
from . import ( diffuse, maps,)


def fitter(roi, nbands=8, select=[0,1], folder='diffuse_fit_maps', 
    corr_min=-0.95, update=False):
    """
    Perform independent fits to the gal, iso for each of the first nbands bands.
    If such a fit fails, or the correlation coeficient less than corr_min, fit only the isotropic.
    select: None or list of variables
    update: if True, modify the correction coefficients
    """

    # thaw gal and iso
    roi.thaw('Norm', 'ring')
    roi.thaw('Scale', 'isotrop')
    roi.get_model('isotrop').bounds[0]=[np.log10(0.5), np.log10(10.0)] # set limits 
    roi.reinitialize()
    
    # do the fitting
    dpars=[]
    energies = []
    covs=[]
    quals = []
    def corr(cov): # correlation coeficiant
        return cov[0,1]/np.sqrt(cov[0,0]*cov[1,1])
    for ie in range(nbands):
        roi.select(ie); 
        energy =int(roi.energies[0]) 
        print ('----- E={} -----'.format(energy))
        roi.fit(select, setpars={0:0, 1:0}, ignore_exception=True)
        cov = roi.fit_info['covariance']
        if cov is None or cov[0,0]<0 or corr(cov)<corr_min:
            #fail, probably since too correlated, or large correlation. So fit only iso
            roi.fit([1], setpars={0:0, 1:0}, ignore_exception=True)
            cov=np.array([ [0, roi.fit_info['covariance'][0]] , [0,0] ])
        energies.append(energy)
        dpars.append( roi.sources.parameters.get_parameters()[:2])
        covs.append(cov)
        quals.append(roi.fit_info['qual'])
    roi.freeze('Norm', 'ring', 1.0)
    roi.freeze('Scale', 'isotrop', 1.0)
    roi.select() # restore

    
    # set to external pars
    df = pd.DataFrame(np.power(10,np.array(dpars)), columns='gal iso'.split())
    df['cov'] = covs
    df['qual'] = quals
    df.index=energies

    if folder is not None:

        if folder=='diffuse_fit_maps':
            if not os.path.exists(folder):
                os.mkdir(folder)
            # new: generate maps instead
            dfa = FitAnalysis(roi, diffuse_fits=df)
            t=dfa.process_bands()
            filename= '{}/{}.pickle'.format(folder, roi.name)
            pickle.dump(t, open(filename, 'w'))
            print ('wrote file {}'.format(filename))

            folder = 'diffuse_fit'
            #old logic
            # save results for diagnostic plots
            if not os.path.exists(folder):
                os.mkdir(folder)
            filename= '{}/{}.pickle'.format(folder, roi.name)
            pickle.dump(df, open(filename, 'w'))
            print ('wrote file {}'.format(filename))
    
    if update:
        # update correction factors, reload all response objects
        dn=diffuse.normalization
        dn['gal'] *= df.gal.values
        dn['iso']['front'] *= df.iso.values
        dn['iso']['back'] *= df.iso.values

        # now reload
        for band in roi:
            for res in band[:2]:
                assert res.source.isglobal
                res.setup=False
                res.initialize()
        print ('Updated coefficients')

    # for interactive: convert covariance matrix to sigmas, correlation
    gsig=[]; isig=[]; corr=[]
    for i in range(len(df)):
        c = df.iloc[i]['cov']
        diag = np.sqrt(c.diagonal())
        gsig.append(diag[0])
        isig.append(diag[1])
        corr.append(c[0,1]/(diag[0]*diag[1]))
    df['gsig']=gsig
    df['isig']=isig
    df['corr']=corr
    del df['cov']

    return df
    

class FitAnalysis(object):
    """Process diffuse analysis, as generated by the fitter
    """
    def __init__(self, roi, roi_index=None, diffuse_fits=None, nside=64):
        """
        """
        self.roi = roi
        if roi_index is not None:
            print ("setting up index {}".format(roi_index))
            roi.setup_roi(roi_index) # Process object external for now
        else:
            roi_index = int(roi.name[-4:])
        self.ri = roi_index
        self.pdirs = map(Band(nside).dir, maps.make_index_table(12,nside)[roi_index])
        print ('Processing ROI index {}'.format(roi_index))

        # load diffuse fits for this model
        if diffuse_fits is None:
            files = sorted(glob.glob('diffuse_fit/*.pickle'))
            assert len(files)>0, 'no files found'
            if len(files)<1728:
                msg= "found {} files, expected 1728".format(len(files))
                print (msg)
                raise Exception(msg)
            # return as an array 1728x8x2, last being (gal,iso)
            self.fa = (pd.read_pickle(files[roi_index]).values[:,:2]).astype(float)
            print ('Loaded diffuse fits for this RoI')
        else:
            self.fa = diffuse_fits.values[:,:2].astype(float)
            print ('Using fits just generated')

        
    def select_band(self, index):
        self.roi.select(index, event_type=None)
        energies = self.roi.energies
        assert len(energies)==1
        self.energy=energies[0]
        print ('Selected {:.0f} MeV'.format(self.energy))
        
        # get the counts in each pixel for gal,iso, and for [front] or [front,back] 
        self.dflux = np.array([[map(resp, self.pdirs)\
                                for resp in sb[:2]] for sb in self.roi.selected])
        
        m = self.dflux.mean(axis=2); s = self.dflux.std(axis=2)/m
        #for a,b in zip(m,s): print ('{:8.0f}, {:.3f}'.format(a,b))
        
    
    def process_band(self, iband, verbose=False):

        self.select_band(iband)

        dflux= self.dflux.astype(float)
        if verbose:
            m = dflux.mean(axis=2); s = dflux.std(axis=2)/m
            ids = 'Front Back'.split() if dflux.shape[0]==2 else ['Front']
            print ('mean\n', pd.DataFrame(m, index=ids, columns='gal iso'.split()))
            print ('rms/mean\n',pd.DataFrame(s, index=ids, columns='gal iso'.split()))

        x=self.fa[iband,:] 
        if verbose: print ('Fits\n', x)

        a64=Band(64).pixelArea()
        f=(dflux*a64); 

        # iso/gal ratio
        r = f[:,1,:]/f[:,0,:]; 
        if verbose: print ('ratio\n', r)

        # adjusted fits per (flux, pixel)
        af = x[0] + r*(x[1]-1); 
        if verbose: print ('adjusted fits\n',af)

        # isolate the galactic flux
        f_gal = f[:,0]; 
        if verbose: print ('galactic fit\n',f_gal)

        # weighted sum of the adjusted fits by the galactic flux
        waf = (f_gal*af).sum(axis=0) / f_gal.sum(axis=0);  
        if verbose: print ('weighted fit\n',self.waf)
        return waf
        
    def process_bands(self, ibands=range(8)):
        return np.array([self.process_band(iband) for iband in ibands])